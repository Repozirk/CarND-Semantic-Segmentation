﻿﻿﻿[//]: # (Image References)[image1]: ./results/Dataset_1.PNG[image2]: ./results/Dataset_2.PNG﻿#Semantic Segmentation ProjectThis is Project 2 of Udacity Self-Driving Car Nanodegree program Term3. In this project, the goal is to label the pixels of a road in images using a Fully Convolutional Network (FCN).The project was created with the Udacity [Starter Code](https://github.com/udacity/CarND-Semantic-Segmentation).## [Rubric](https://review.udacity.com/#!/rubrics/989/view) Points## Content of this repo - `data` a directory with the  "Kitti Road dataset" for training the NN. - `runs` a Directory with test images - `main.py` - where the FCN is located  - `helper.py` - including helper functions and the VGG16 model - `project_test.py` - for testing the code - `README.md` Description of the Project by Udacity - `writeup.md` for submission of this Project#######Result####Architecture#########Cost FunctionThen the closest vehicle in front of the car has to be extracted out of the sensor fusion data. With this information, the speed adjustment was done depending on the predicted distance to the closest vehicle  (main.cpp, line 361).```// set the target_speed close to the velocity of vehicle in front                  if ( pred_dist_delta <= range_avoid_collision)                  {                    target_speed =  car_speed_sf * 0.5 * ms_to_mph;                    too_close = true;                  }                  // avoid collision, target speed below speed of vehicle in front                  else if (pred_dist_delta <= range_adapt_speed )                  {                    target_speed =  car_speed_sf * ms_to_mph;                    too_close = true;                  }                  // set target speed to speed limit                  else                  {                    target_speed = speed_limit;                    too_close = false;                  }```There are 3 cost functions for the situation following a vehicle which result in a sum cost for keeping the lane (main.cpp, line 382). The first cost function depends on the relation target speed and speed limit penalizing low speed.```Speed_cost_KL = (speed_limit - (target_speed))/(speed_limit);```The cost function to penalize collision situations is a binary reaction depending on the distance value```Collision_cost_KL = 0;                    if (car_dist_sf < (3.0 * verhicle_radius))                    {                      Collision_cost_KL = 1;                    }                    else                    {                      Collision_cost_KL = 0;                    }```The last cost function penalizes situations, where vehicles are in the near surrounding. This part helps finding trajectories on lanes with free space.```Buffer_cost_KL = 2.0 / (1 + exp(-(2.0 * verhicle_radius / car_dist_sf))) - 1.0;```#####The cost function for  a path on the right or left lane are identical for speed and collision. The buffer cost takes a speed ratio into account. To avoid collisions during lane change,  the total cost  is increased to high values recognizing vehicles in specific situations. These situations are (main.cpp, line 481):- the predicted s-distance or the total distance of the car and the nearest vehicle is smaller than the adjustable range value `range_avoid_collision_lc` to avoid collision- or the  predicted s-distance of the nearest vehicle with higher speed as the car is less than a third of `range_avoid_collision_lc` and greater than twice `range_avoid_collision_lc`With this cost increase, a  lane change is only performed, when there is no chance of collision.#########Lane ChangeTo avoid high frequency lane changes, a minium distance of 150m is necessary to get the permission for the next lane Change.The decision of a lane change is done with the logic below by comparison of total cost for "Keep Lane",. "Lane Change Left" and "Lane Change Right" (main.cpp, line 605).```// Find trajectory with min cost for lane change            if (too_close == true && lane_change_allowed == true)            {              if ((sum_cost_LCL < sum_cost_KL) && (sum_cost_LCL <= sum_cost_LCR))              {                lane -= 1;                car_s_last_lc = car_s;                target_speed = target_speed_LCL;              }              if ((sum_cost_LCR < sum_cost_KL) && (sum_cost_LCR < sum_cost_LCL))              {                lane += 1;                car_s_last_lc = car_s;                target_speed = target_speed_LCR;              }            }```#########Summary